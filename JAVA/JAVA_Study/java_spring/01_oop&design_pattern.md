## 객체지향

#### 객체지향의 4대 특성

##### 1. 캡슐화

- 객체의 속성(Variable)을 보호하기 위해 사용
  - 컴퓨터 전원을 켜기 위해 메인보드에 전기신호를 직접 주는 것이 아닌 외부 케이스의 전원 버튼을 이용함
- Method 설계
  - 송성이 선언 되었으나 상태를 변경하는 method가 없다면 잘못 선언 된 속성이다.
  - 실물 객체가 가진 기능을 모두 제공해야 한다.
  - 각각의 Method는 서로 관련성이 있어야 한다
    - 등록/해지, 생성/삭제 등
  - 객체 안의  Method는 객체 안의 속성을 처리해야 한다
    - 다른 객체를 전달받아 해당 다른 객체에 정의 된 속성을 직접 처리해서는 안 된다
    - 단, Method 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달 되어져야 한다.
  - Getter/Setter Method
    - 외부에서 내부 속성에 직접 접근해서는 안됨
  - CRUD Method
  - Business Logic Method
  - 객체 생명 주기 처리 Method
    - destroy(), disconnect(), qeit() 등 소멸에 대한 method
  - 객체 영구성 관리 Method
    - 영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가하도록 private으로 선언하면, 내부의 다른 Method를 통해 사용 되도록 한다.
  - Method의 속성은 반드시 1개에 속할 필요는 없고, 여러 속성에 해달 될 수 있다.
- 장점
  - 객체지향의 패러다임 중 하나인 추상화 제공
    - 단순 호출만으로 해당 기능을 실행할 수 있고 이를 통해 객체 단위 프로그램 설계 가능
  - 재 사용성 향상
    - 한 객체에 관련된 속성 및 Method는 모두 캡슐화의 형태로 제공 되기에 모듈성과 응집도가 높아짐
    - 객체의 경우 단일 객체에만 영향을 주기 때문에 전체 프로그램에 영향을 주지 않아 재 사용성이 높음
  - 유지보수의 효율성 향상
- 무결성 보장
  - Getter/Setter를 제외 하고는 public method는 입력된 매개변수를 Validation을 한 후에 실행하는 것을 기본으로 함
  - Validation을 통해 객체의 값을 변경 할 때 유효성을 가질 수 있음 

<br/>

##### 2.상속

- 객체지향에서의 상속은 하위로 내려 갈수록 구체화 되는 것을 의미
- 상속의 효과
  - 프로그램 구조에 대한 이해도 향상
    - 최상위 클래스의 구조를 보고 하위 클래스의 동작을 이해 할 수 있음
  - 재사용성 향상
    - 상속을 이용하여 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고 상속을 받아서 사용 할 수 있다
  - 확장성 향상
    - 일관된 형태의 객체를 추가 할 수 있어 간단하게 프로그램 확장 가능
  - 유지보수성 향상
    - 각 객체마다 일관된 형태를 지니기 때문

<br/>

##### 3. 다형성

- 하나의 개체가 여러 형태로 변화하는 것을 의미
  - Overriding을 통해 가능
- 같은 이름의 Method를 이용해 각자의 개체에 맞는 여러 형태의 다른 기능을 구현 할 수 있음

<br/>

##### 4. 추상화

- Modeling을 의미
- 구체적으로 공통적인 부분, 또는 특정 특성을 분리해 재조합하는 부분
- 다형성, 상속 모두 추상화에 속함

<br/>

___

#### 객체지향 5원칙 SOLID

##### 1. SRP (단일 책임의 원칙 : Single Responsibility Principle)

- 결합도(Coupling)은 낮추고 응집도(Cohesion)은 높여야 한다
  - **결합도**
    - 모듈(클래스)간의 상호 의존 정도를 나타내는 지표
    - 결합도가 낮으면 상호 의존성이 줄어서 재사용 및 유지보수 유리
  - **응집도**
    - 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
    - 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용 및 유지보수 유리
- 상속, 오버라이딩을 사용

<br/>

##### 2. OCP (개방 폐쇄의 원칙 : Open Close Principle)

- 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- 상위 클래스 또는 인터페이스를 중간에 두어 자신의 변화에 대해서는 폐쇄하고 인터페이스는 외부의 변화에 대해 확장성을 개방한다.
  - JDBC, Mybatis, Hibernate 등, 그리고 JAVA에서는 Stream(Input,Output)에서 찾아볼 수 있다.

<br/>

##### 3. LSP (리스코브 치환의 원칙 : The Liskov Subsitution Principle)

- 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체 할 수 있어야 한다.

- 예시 : 상위 : 자동차/운송수단 - 하위:아반테,그렌져

<br/>

##### 4. ISP (인터페이스 분리의 원칙 : Interface Segregation Principle)

- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
  - 인터페이스로 각 기능을 분리하여 사용하는 메서드에만 의존 관계를 맺는다.
- 프로젝트 요구사항과 설계에 따라 SRP(단일 책임 원칙) 또는 ISP(인터페이스분리원칙)을 선택한다.

<br/>

##### DIP (의존성 역전의 원칙 : Dependency Inversion Principle)

 - 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
   	- 개발폐쇄 원칙에서도 살펴본 내용
   	- SOLID는 객체 지향 4대 특성에 기반하기에 유사한 모양을 지님

<br/>

## 디자인 패턴

#### 디자인 패턴이란?

- 자주 사용하는 설계 패턴을 정형화해서 유형별로 가장 최적의 방법으로 개발 할 수 있도록 정해 둔 설계
- 명확한 정답이 있는 것이 아니고, 프로젝트의 상황에 맞추어 적용 가능

<br/>

#### Gof의 디자인 패턴 (Goang of Four)

- 객체 지향 개념에 따른 설계 중 재사용할 경우 유용한 설계를 정리 해둔 것

- 총 23개

<br/>

- 장점
  - 개발자(설계자) 간의 원활한 소통
  - 소프트웨어 구조 파악 용이
  - 재사용을 통한 개발 시간 단축
  - 설계 변경 요청에 대한 유용한 대처
- 단점
  - 모든 개발자의 객체지향 설계 / 구현에 대한 이해
  - 초기 투자 비용 부담

<br/>

##### 생성 패턴

- 객체를 생성하는 것과 관련 된 패턴
-  객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화하고 코드의 유연성을 높여 줌
  - Factory Method
  - **Singleton**
  - Prototype
  - **Builder**
  - Abstract Factory
  - **Chaining - gof에 나오는 것은 아님(lombok을 이용해 설정)**

<br/>

##### 구조 패턴

- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는 데 활용 될 수 있는 패턴
- 클래스, 객체들의 구성을 통해 더 큰 구조를 만들 수 있게 해줌
- 큰 규모의 시스템에서는 많은 클래스들이 서로 의존성을 가지게 되는데, 이런 복잡한 구조의 개발 및 유지보수를 쉽게 해줌
  - **Adapter**
  - Composite
  - Bridge
  - **Decorator**
  - **Facade**
  - Flyweight
  - **Proxy**

<br/>

##### 행위 패턴

- 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것
- 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 제공
- 행위 패턴은 행위 관련 패턴을 사용하여 독립적으로 일을 처리하고자 할 때 사용
  - Template Method
  - Interpreter
  - Iterator
  - **Observer**
  - **Strategy**
  - Visitor
  - Chain of responsibility
  - Command
  - Mediator
  - State
  - Memento

<br/>