## 객체지향

#### 객체지향의 4대 특성

##### 1. 캡슐화

- 객체의 속성(Variable)을 보호하기 위해 사용
  - 컴퓨터 전원을 켜기 위해 메인보드에 전기신호를 직접 주는 것이 아닌 외부 케이스의 전원 버튼을 이용함
- Method 설계
  - 송성이 선언 되었으나 상태를 변경하는 method가 없다면 잘못 선언 된 속성이다.
  - 실물 객체가 가진 기능을 모두 제공해야 한다.
  - 각각의 Method는 서로 관련성이 있어야 한다
    - 등록/해지, 생성/삭제 등
  - 객체 안의  Method는 객체 안의 속성을 처리해야 한다
    - 다른 객체를 전달받아 해당 다른 객체에 정의 된 속성을 직접 처리해서는 안 된다
    - 단, Method 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달 되어져야 한다.
  - Getter/Setter Method
    - 외부에서 내부 속성에 직접 접근해서는 안됨
  - CRUD Method
  - Business Logic Method
  - 객체 생명 주기 처리 Method
    - destroy(), disconnect(), qeit() 등 소멸에 대한 method
  - 객체 영구성 관리 Method
    - 영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가하도록 private으로 선언하면, 내부의 다른 Method를 통해 사용 되도록 한다.
  - Method의 속성은 반드시 1개에 속할 필요는 없고, 여러 속성에 해달 될 수 있다.
- 장점
  - 객체지향의 패러다임 중 하나인 추상화 제공
    - 단순 호출만으로 해당 기능을 실행할 수 있고 이를 통해 객체 단위 프로그램 설계 가능
  - 재 사용성 향상
    - 한 객체에 관련된 속성 및 Method는 모두 캡슐화의 형태로 제공 되기에 모듈성과 응집도가 높아짐
    - 객체의 경우 단일 객체에만 영향을 주기 때문에 전체 프로그램에 영향을 주지 않아 재 사용성이 높음
  - 유지보수의 효율성 향상
- 무결성 보장
  - Getter/Setter를 제외 하고는 public method는 입력된 매개변수를 Validation을 한 후에 실행하는 것을 기본으로 함
  - Validation을 통해 객체의 값을 변경 할 때 유효성을 가질 수 있음 

<br/>

##### 2.상속

- 객체지향에서의 상속은 하위로 내려 갈수록 구체화 되는 것을 의미
- 상속의 효과
  - 프로그램 구조에 대한 이해도 향상
    - 최상위 클래스의 구조를 보고 하위 클래스의 동작을 이해 할 수 있음
  - 재사용성 향상
    - 상속을 이용하여 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고 상속을 받아서 사용 할 수 있다
  - 확장성 향상
    - 일관된 형태의 객체를 추가 할 수 있어 간단하게 프로그램 확장 가능
  - 유지보수성 향상
    - 각 객체마다 일관된 형태를 지니기 때문

<br/>

##### 3. 다형성

- 하나의 개체가 여러 형태로 변화하는 것을 의미
  - Overriding을 통해 가능
- 같은 이름의 Method를 이용해 각자의 개체에 맞는 여러 형태의 다른 기능을 구현 할 수 있음

<br/>

##### 4. 추상화

- Modeling을 의미
- 구체적으로 공통적인 부분, 또는 특정 특성을 분리해 재조합하는 부분
- 다형성, 상속 모두 추상화에 속함

<br/>

___

#### 객체지향 5원칙 SOLID

##### 1. SRP (단일 책임의 원칙 : Single Responsibility Principle)

- 결합도(Coupling)은 낮추고 응집도(Cohesion)은 높여야 한다
  - **결합도**
    - 모듈(클래스)간의 상호 의존 정도를 나타내는 지표
    - 결합도가 낮으면 상호 의존성이 줄어서 재사용 및 유지보수 유리
  - **응집도**
    - 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
    - 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용 및 유지보수 유리
- 상속, 오버라이딩을 사용

<br/>

##### 2. OCP (개방 폐쇄의 원칙 : Open Close Principle)

- 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- 상위 클래스 또는 인터페이스를 중간에 두어 자신의 변화에 대해서는 폐쇄하고 인터페이스는 외부의 변화에 대해 확장성을 개방한다.
  - JDBC, Mybatis, Hibernate 등, 그리고 JAVA에서는 Stream(Input,Output)에서 찾아볼 수 있다.

<br/>

##### 3. LSP (리스코브 치환의 원칙 : The Liskov Subsitution Principle)

- 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체 할 수 있어야 한다.

- 예시 : 상위 : 자동차/운송수단 - 하위:아반테,그렌져

<br/>

##### 4. ISP (인터페이스 분리의 원칙 : Interface Segregation Principle)

- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
  - 인터페이스로 각 기능을 분리하여 사용하는 메서드에만 의존 관계를 맺는다.
- 프로젝트 요구사항과 설계에 따라 SRP(단일 책임 원칙) 또는 ISP(인터페이스분리원칙)을 선택한다.

<br/>

##### DIP (의존성 역전의 원칙 : Dependency Inversion Principle)

 - 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
   	- 개발폐쇄 원칙에서도 살펴본 내용
      	- SOLID는 객체 지향 4대 특성에 기반하기에 유사한 모양을 지님

<br/>

