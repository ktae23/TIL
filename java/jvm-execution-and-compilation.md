# JVM 실행 흐름과 컴파일러

JVM의 바이트코드 실행 흐름과 컴파일러 (인터프리터, JIT, AOT, GraalVM)에 대한 상세 분석입니다.

**기준 버전**: Java 8 → Java 17+ 변경사항 포함

## 목차

- [전체 실행 과정](#전체-실행-과정-상세)
- [메서드 호출과 Stack Frame](#메서드-호출-예시-stack-frame-생성-과정)
- [실행 엔진 비교](#실행-엔진-비교)
  - [Java 8: 인터프리터 + JIT](#java-8-인터프리터--jit-컴파일러)
  - [Java 9+: AOT 컴파일러](#java-9-aot-ahead-of-time-컴파일러-추가)
  - [Java 17+: GraalVM Native Image](#java-17-aotgraal-jit-제거-및-graalvm-native-image로의-전환)
- [참고 자료](#참고-자료)

---

## 실행 흐름

### 전체 실행 과정 (상세)

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 개발 단계: 소스 코드 작성                                      │
│    Example.java                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. 컴파일: javac 컴파일러                                         │
│    - 소스 코드(.java) → 바이트코드(.class) 변환                   │
│    - 어노테이션 프로세서 실행 (컴파일 타임 코드 생성)              │
│    Example.class (바이트코드)                                     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. JVM 시작: java Example                                        │
│    - JVM 프로세스 생성                                            │
│    - 메모리 영역 초기화 (Heap, Metaspace, Stack 등)               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. 클래스 로딩: Class Loader Subsystem                            │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 4-1. Loading (로딩)                                   │     │
│    │      - .class 파일을 메모리로 로드                     │     │
│    │      - 위임 모델: Bootstrap → Extension → Application │     │
│    └──────────────────────────────────────────────────────┘     │
│                           ↓                                      │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 4-2. Linking (링킹)                                   │     │
│    │      - Verification: 바이트코드 검증                   │     │
│    │      - Preparation: static 변수 기본값 초기화          │     │
│    │      - Resolution: 심볼릭 참조 → 실제 주소 변환        │     │
│    └──────────────────────────────────────────────────────┘     │
│                           ↓                                      │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 4-3. Initialization (초기화)                          │     │
│    │      - static 변수 실제 값 할당                        │     │
│    │      - static 블록 실행                                │     │
│    └──────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. 실행 엔진: Execution Engine                                    │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 바이트코드 → 기계어 변환                              │     │
│    │                                                       │     │
│    │  ┌─────────────┐          ┌──────────────┐          │     │
│    │  │ 인터프리터   │          │ JIT 컴파일러  │          │     │
│    │  │             │          │              │          │     │
│    │  │ - 한줄씩 해석│ ──────→  │ - Hot Spot   │          │     │
│    │  │ - 초기 실행  │  빈번한   │   감지       │          │     │
│    │  │             │  코드     │ - 네이티브   │          │     │
│    │  │             │  발견시   │   코드 생성  │          │     │
│    │  └─────────────┘          └──────────────┘          │     │
│    └──────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 6. 런타임 실행                                                    │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 메서드 호출                                           │     │
│    │  ↓                                                    │     │
│    │ Stack에 Frame 생성                                    │     │
│    │  - 지역 변수 할당                                      │     │
│    │  - Operand Stack (연산 스택)                          │     │
│    │  - Return Address                                     │     │
│    └──────────────────────────────────────────────────────┘     │
│                           ↓                                      │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ 객체 생성 (new 키워드)                                │     │
│    │  ↓                                                    │     │
│    │ Heap의 Eden 영역에 메모리 할당                         │     │
│    │  - 생성자 실행                                         │     │
│    │  - 참조값을 Stack의 지역 변수에 저장                   │     │
│    └──────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 7. 가비지 컬렉션 (GC)                                             │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ Minor GC (Young Generation)                           │     │
│    │  - Eden 영역 가득 차면 실행                            │     │
│    │  - 살아있는 객체 → Survivor로 이동                     │     │
│    │  - 일정 횟수 생존 → Old Generation으로 이동 (Promotion)│     │
│    └──────────────────────────────────────────────────────┘     │
│                           ↓                                      │
│    ┌──────────────────────────────────────────────────────┐     │
│    │ Major GC (Old Generation)                             │     │
│    │  - Old 영역 가득 차면 실행                             │     │
│    │  - STW (Stop-The-World) 발생                          │     │
│    │  - 애플리케이션 일시 중지                              │     │
│    └──────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
```

### 메서드 호출 예시 (Stack Frame 생성 과정)

```java
public class Example {
    public static void main(String[] args) {  // Frame 1
        int result = calculate(5);             // Frame 2 생성 예정
        System.out.println(result);
    }

    public static int calculate(int num) {     // Frame 2
        int temp = num * 2;                    // Frame 2의 지역 변수
        return temp;
    }
}
```

**Stack 상태 변화:**

```
1. main() 호출 시
┌──────────────┐
│  Frame 1     │
│  main()      │
│ ─────────    │
│ args: [...]  │
└──────────────┘

2. calculate(5) 호출 시
┌──────────────┐
│  Frame 2     │ ← 현재 실행
│ calculate()  │
│ ─────────    │
│ num: 5       │
│ temp: 10     │
├──────────────┤
│  Frame 1     │
│  main()      │
│ ─────────    │
│ args: [...]  │
│ result: ?    │
└──────────────┘

3. calculate() 종료 후
┌──────────────┐
│  Frame 1     │
│  main()      │
│ ─────────    │
│ args: [...]  │
│ result: 10   │ ← 반환값 저장
└──────────────┘
```

### 실행 엔진 비교

#### Java 8: 인터프리터 + JIT 컴파일러

**동작 흐름:**

```
바이트코드 실행
     ↓
┌─────────────────┐
│  인터프리터      │ ← 초기 실행 (즉시 시작)
└─────────────────┘
     ↓
  Hot Spot 감지
  (메서드 호출 횟수 카운팅)
     ↓
┌─────────────────┐
│ JIT C1 컴파일러  │ ← Client 컴파일러 (빠른 컴파일)
│ (Client)        │   - 기본 최적화
└─────────────────┘   - 적은 컴파일 시간
     ↓
  더 많은 호출 감지
     ↓
┌─────────────────┐
│ JIT C2 컴파일러  │ ← Server 컴파일러 (고도 최적화)
│ (Server)        │   - 인라이닝, 루프 최적화
└─────────────────┘   - 긴 컴파일 시간
     ↓
  네이티브 코드 캐싱
  (Code Cache에 저장)
```

**비교표 (Java 8):**

| 방식 | 동작 원리 | 장점 | 단점 | 사용 시점 | Hot Spot 임계값 |
|------|----------|------|------|---------|----------------|
| **인터프리터** | 바이트코드를 한 줄씩 읽어 즉시 실행 | 즉시 실행 가능, 메모리 효율적 | 느린 실행 속도 (10-100배 느림) | 프로그램 초기 실행, 한 번만 실행되는 코드 | - |
| **JIT C1** | Hot Spot 코드를 네이티브 코드로 컴파일 | 빠른 실행 속도, 짧은 컴파일 시간 | C2보다 최적화 부족 | 반복 실행되는 코드 | 1,500회 호출 |
| **JIT C2** | 고도로 최적화된 네이티브 코드 생성 | 매우 빠른 실행 속도 | 긴 컴파일 시간 (워밍업) | 매우 자주 실행되는 코드 | 10,000회 호출 |

**JIT 컴파일 최적화 기법:**
- **인라이닝 (Inlining)**: 메서드 호출을 메서드 본문으로 치환
- **루프 최적화**: 루프 펼치기, 루프 병합
- **Escape Analysis**: 객체가 메서드 외부로 탈출하지 않으면 Stack 할당
- **Dead Code Elimination**: 실행되지 않는 코드 제거

#### Java 9+: AOT (Ahead-of-Time) 컴파일러 추가

**AOT 컴파일러 도입 배경:**
- **문제**: JIT는 런타임에 컴파일하므로 워밍업 시간 필요
- **필요성**: 클라우드 네이티브 환경에서 빠른 시작 시간 요구
- **해결**: 실행 전에 미리 네이티브 코드로 컴파일

**AOT 컴파일 흐름:**

```
┌─────────────────────────────────────┐
│ 1. 컴파일 타임 (개발 단계)           │
│    jaotc 도구 사용                   │
└─────────────────────────────────────┘
         ↓
    .class 파일
         ↓
┌─────────────────────────────────────┐
│ $ jaotc --output mylib.so \         │
│         --module java.base          │
└─────────────────────────────────────┘
         ↓
    .so 파일 (네이티브 코드)
         ↓
┌─────────────────────────────────────┐
│ 2. 런타임 (실행 시)                  │
│    $ java -XX:AOTLibrary=./mylib.so │
│           MyApp                     │
└─────────────────────────────────────┘
         ↓
    즉시 네이티브 코드 실행
    (JIT 워밍업 불필요)
```

**Java 8 vs Java 9+ 실행 엔진 비교:**

| 항목 | Java 8 | Java 9+ | 차이점 |
|------|--------|---------|--------|
| **컴파일 방식** | JIT (런타임) | JIT + AOT (선택 가능) | AOT는 사전 컴파일 |
| **시작 시간** | 느림 (워밍업 필요) | 빠름 (AOT 사용 시) | 워밍업 시간 제거 |
| **Peak 성능** | 매우 높음 (C2 최적화) | JIT와 동일 | AOT는 런타임 정보 없어 최적화 제한 |
| **메모리 사용** | Code Cache 필요 | .so 파일 로드 | AOT는 메모리 절약 |
| **적합한 환경** | 장시간 실행 서버 | 짧은 실행 (Lambda, CLI) | 사용 패턴에 따라 선택 |
| **프로파일링** | 런타임 프로파일링 가능 | 사전 컴파일로 제한적 | JIT가 더 정확한 최적화 |

**AOT 사용 예시:**

```bash
# 1. Java 모듈을 AOT 컴파일
jaotc --output java.base.so --module java.base

# 2. 애플리케이션 실행 (AOT 라이브러리 사용)
java -XX:AOTLibrary=./java.base.so MyApp

# 3. 성능 측정
# - 시작 시간: 30-70% 단축
# - Peak 성능: JIT보다 5-10% 낮음 (런타임 최적화 부족)
```

**AOT의 장단점:**

| 장점 | 단점 |
|------|------|
| ✅ 빠른 시작 시간 (워밍업 불필요) | ❌ Peak 성능이 JIT보다 낮음 (런타임 정보 부족) |
| ✅ 예측 가능한 성능 (사전 컴파일) | ❌ 플랫폼 종속적 (.so 파일은 OS별로 다름) |
| ✅ 메모리 효율적 (Code Cache 불필요) | ❌ 컴파일 파일 크기 증가 |
| ✅ 보안 향상 (디컴파일 어려움) | ❌ 동적 클래스 로딩 지원 제한 |

**적합한 사용 사례:**
- **AOT 추천**: 서버리스 (AWS Lambda), CLI 도구, 마이크로서비스 (빠른 스케일링)
- **JIT 추천**: 장시간 실행 서버, 높은 처리량 필요 애플리케이션

#### Java 17+: AOT/Graal JIT 제거 및 GraalVM Native Image로의 전환

**변경 이유:**
- Java 9-16의 `jaotc` 기반 AOT는 제한적인 성능 향상
- 플랫폼 종속적이고 유지보수 비용 증가
- **GraalVM Native Image**가 더 우수한 대안으로 부상

**Java AOT vs GraalVM Native Image 비교:**

| 항목 | Java AOT (Java 9-16) | GraalVM Native Image (Java 17+) |
|------|---------------------|----------------------------------|
| **컴파일 범위** | 일부 모듈만 AOT 컴파일 | 전체 애플리케이션을 네이티브 바이너리로 컴파일 |
| **런타임** | 여전히 JVM 필요 | **JVM 불필요 (독립 실행 파일)** |
| **시작 시간** | 30-70% 단축 | **90% 이상 단축 (밀리초 단위)** |
| **메모리 사용** | JVM 오버헤드 존재 | **매우 낮음 (1/10 수준)** |
| **Peak 성능** | JIT보다 5-10% 낮음 | JIT보다 10-30% 낮음 (트레이드오프) |
| **배포 크기** | JRE 포함 필요 (수십 MB) | **단일 바이너리 (수 MB)** |
| **플랫폼 지원** | JVM 지원 플랫폼 | OS별 네이티브 바이너리 빌드 |
| **리플렉션 지원** | 완전 지원 | 제한적 (사전 등록 필요) |

**GraalVM Native Image 동작 방식:**

```
┌─────────────────────────────────────────┐
│ 1. Java 애플리케이션 코드               │
│    MyApp.java + 의존성 라이브러리       │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 2. AOT 컴파일 (native-image 도구)       │
│    - 정적 분석 (Closed World Assumption)│
│    - 사용되는 모든 클래스/메서드 탐색    │
│    - 리플렉션/동적 프록시 사전 등록      │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 3. 네이티브 코드 생성                    │
│    - Substrate VM (경량 VM) 포함        │
│    - GC 포함 (Serial GC 또는 G1 GC)     │
│    - 모든 클래스를 네이티브 코드로 변환  │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ 4. 네이티브 바이너리 생성                │
│    myapp (실행 파일)                    │
│    - JVM 불필요                         │
│    - OS 직접 실행                       │
└─────────────────────────────────────────┘
```

**GraalVM Native Image 사용 예시:**

```bash
# 1. GraalVM 설치
sdk install java 21-graal

# 2. Native Image 빌드
native-image -jar myapp.jar myapp

# 빌드 옵션:
# --no-fallback : 런타임 컴파일 완전 비활성화
# -H:+ReportExceptionStackTraces : 빌드 오류 상세 출력
# --initialize-at-build-time=<class> : 빌드 타임에 초기화

# 3. 실행 (JVM 불필요!)
./myapp

# 성능 측정:
# 시작 시간: 0.005s (기존 JVM: 0.5s, 100배 빠름)
# 메모리 사용: 10MB (기존 JVM: 100MB, 1/10 수준)
```

**Spring Boot + GraalVM Native Image:**

```java
// Spring Boot 3.0+ 기본 지원
// pom.xml
<plugin>
    <groupId>org.graalvm.buildtools</groupId>
    <artifactId>native-maven-plugin</artifactId>
</plugin>

// 빌드
mvn -Pnative native:compile

// 결과:
// - 시작 시간: 0.05초 (기존 2-3초 → 50배 빠름)
// - 메모리: 20MB (기존 200MB → 1/10)
// - 컨테이너 이미지: 50MB (기존 200MB → 1/4)
```

**GraalVM Native Image 제약사항 및 해결책:**

| 제약사항 | 이유 | 해결책 |
|---------|------|--------|
| **리플렉션 사전 등록** | 정적 분석으로 리플렉션 대상 파악 불가 | `reflect-config.json` 작성 또는 자동 생성 |
| **동적 프록시 제한** | 런타임 클래스 생성 불가 | `proxy-config.json` 작성 |
| **JNI 호출** | 네이티브 코드 호출 사전 등록 필요 | `jni-config.json` 작성 |
| **클래스 패스 스캐닝** | 런타임 클래스 로딩 불가 | 빌드 타임에 모든 클래스 포함 |

**리플렉션 설정 예시:**

```json
// reflect-config.json
[
  {
    "name": "com.example.MyClass",
    "allDeclaredMethods": true,
    "allDeclaredFields": true,
    "allDeclaredConstructors": true
  }
]
```

**자동 설정 생성 (Agent 사용):**

```bash
# 1. Agent로 애플리케이션 실행 (메타데이터 수집)
java -agentlib:native-image-agent=config-output-dir=META-INF/native-image \
     -jar myapp.jar

# 2. 수집된 설정 파일로 Native Image 빌드
native-image -jar myapp.jar
```

**언제 GraalVM Native Image를 사용할까?**

✅ **추천하는 경우:**
- 서버리스 환경 (AWS Lambda, Google Cloud Functions)
- 컨테이너 기반 마이크로서비스 (빠른 스케일링)
- CLI 도구 (즉각적인 실행)
- IoT 디바이스 (제한된 리소스)
- 클라우드 비용 절감 (낮은 메모리 사용)

❌ **권장하지 않는 경우:**
- 리플렉션/동적 프록시를 많이 사용하는 레거시 애플리케이션
- 최고 성능(Peak Performance)이 중요한 장시간 실행 서버
- 빌드 시간이 매우 중요한 경우 (Native Image 빌드는 느림, 수 분 소요)

**결론:**

| 환경 | 권장 방식 |
|------|---------|
| 전통적인 서버 애플리케이션 | **JIT (JVM)** |
| 서버리스, 마이크로서비스 | **GraalVM Native Image** |
| 개발/테스트 환경 | **JIT (빠른 빌드)** |
| 프로덕션 (클라우드) | **GraalVM Native Image (비용 절감)** |

---

## 참고 자료

- [Oracle Java 8 JVM Specification](https://docs.oracle.com/javase/specs/jvms/se8/html/)
- [JIT Compiler Overview](https://docs.oracle.com/en/java/javase/11/vm/java-virtual-machine-technology-overview.html)
- [GraalVM Native Image](https://www.graalvm.org/latest/reference-manual/native-image/)

---

*마지막 업데이트: 2025년 12월*
