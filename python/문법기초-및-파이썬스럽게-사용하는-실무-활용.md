# 문법기초 및 파이썬스럽게 사용하는 실무 활용

Python의 기본 문법부터 Pythonic한 코드 작성 방법까지, 실무에서 자주 사용되는 패턴과 관용구를 정리한 문서입니다.

## 목차

1. [Python 기본 문법](#python-기본-문법)
2. [Pythonic 코드 작성하기](#pythonic-코드-작성하기)
3. [리스트 컴프리헨션](#리스트-컴프리헨션)
4. [제너레이터와 이터레이터](#제너레이터와-이터레이터)
5. [컨텍스트 매니저](#컨텍스트-매니저)
6. [데코레이터](#데코레이터)
7. [타입 힌트](#타입-힌트)
8. [실무 베스트 프랙티스](#실무-베스트-프랙티스)

---

## Python 기본 문법

### 변수와 자료형

```python
# 동적 타이핑
name = "Python"
version = 3.12
is_awesome = True

# 여러 변수 동시 할당
x, y, z = 1, 2, 3

# 값 교환 (Pythonic way)
a, b = 10, 20
a, b = b, a  # swap
```

### 문자열 다루기

```python
# f-string (Python 3.6+, 가장 권장)
name = "홍길동"
age = 30
message = f"{name}님의 나이는 {age}세입니다."

# 여러 줄 문자열
multi_line = """
첫 번째 줄
두 번째 줄
세 번째 줄
"""

# 문자열 메서드 체이닝
text = "  hello world  "
result = text.strip().upper().replace("WORLD", "PYTHON")
# "HELLO PYTHON"
```

### 컬렉션 자료형

```python
# 리스트 (가변)
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
numbers.extend([7, 8, 9])

# 튜플 (불변)
coordinates = (10, 20)
x, y = coordinates  # unpacking

# 딕셔너리
user = {
    "name": "김철수",
    "age": 25,
    "email": "kim@example.com"
}

# get 메서드 활용 (KeyError 방지)
phone = user.get("phone", "정보 없음")

# 셋 (중복 제거, 집합 연산)
unique_numbers = {1, 2, 3, 3, 4, 4, 5}  # {1, 2, 3, 4, 5}
```

---

## Pythonic 코드 작성하기

### EAFP vs LBYL

**EAFP (Easier to Ask for Forgiveness than Permission)** - Python 권장 방식

```python
# Pythonic way (EAFP)
try:
    value = my_dict[key]
except KeyError:
    value = default_value

# vs Non-Pythonic way (LBYL)
if key in my_dict:
    value = my_dict[key]
else:
    value = default_value
```

### Truthy/Falsy 활용

```python
# Pythonic way
items = []
if not items:
    print("리스트가 비어있습니다")

# vs Non-Pythonic way
if len(items) == 0:
    print("리스트가 비어있습니다")

# Falsy 값들: None, False, 0, 0.0, '', [], {}, set()
```

### enumerate와 zip

```python
# enumerate로 인덱스와 값 함께 얻기
fruits = ["사과", "바나나", "오렌지"]
for idx, fruit in enumerate(fruits, start=1):
    print(f"{idx}. {fruit}")

# zip으로 여러 시퀀스 동시 순회
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
cities = ["Seoul", "Busan", "Incheon"]

for name, age, city in zip(names, ages, cities):
    print(f"{name} ({age}세) - {city}")
```

### unpacking 활용

```python
# 리스트 unpacking
first, *middle, last = [1, 2, 3, 4, 5]
# first=1, middle=[2,3,4], last=5

# 딕셔너리 unpacking
defaults = {"host": "localhost", "port": 8000}
config = {"port": 9000, "debug": True}
merged = {**defaults, **config}
# {"host": "localhost", "port": 9000, "debug": True}

# 함수 인자 unpacking
def process(name, age, city):
    print(f"{name}, {age}, {city}")

user_data = ["홍길동", 30, "서울"]
process(*user_data)  # positional unpacking

user_dict = {"name": "김철수", "age": 25, "city": "부산"}
process(**user_dict)  # keyword unpacking
```

---

## 리스트 컴프리헨션

### 기본 사용법

```python
# 일반 for 문
squares = []
for x in range(10):
    squares.append(x ** 2)

# 리스트 컴프리헨션 (Pythonic)
squares = [x ** 2 for x in range(10)]

# 조건문 포함
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]
```

### 중첩 컴프리헨션

```python
# 2차원 리스트 평탄화
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 딕셔너리 컴프리헨션
words = ["apple", "banana", "cherry"]
word_lengths = {word: len(word) for word in words}
# {"apple": 5, "banana": 6, "cherry": 6}

# 셋 컴프리헨션
text = "hello world"
unique_chars = {char for char in text if char != ' '}
# {'d', 'e', 'h', 'l', 'o', 'r', 'w'}
```

### 조건부 표현식

```python
# 삼항 연산자 스타일
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
labels = ["짝수" if n % 2 == 0 else "홀수" for n in numbers]
```

---

## 제너레이터와 이터레이터

### 제너레이터 표현식

```python
# 리스트 컴프리헨션 (메모리에 전체 리스트 생성)
sum_squares_list = sum([x ** 2 for x in range(1000000)])

# 제너레이터 표현식 (메모리 효율적, Pythonic)
sum_squares_gen = sum(x ** 2 for x in range(1000000))
```

### 제너레이터 함수

```python
# yield를 사용한 제너레이터
def fibonacci(n):
    """첫 n개의 피보나치 수를 생성"""
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 사용
for num in fibonacci(10):
    print(num)

# 무한 제너레이터
def infinite_counter(start=0):
    """무한 카운터"""
    num = start
    while True:
        yield num
        num += 1

# itertools와 함께 사용
from itertools import islice
counter = infinite_counter()
first_10 = list(islice(counter, 10))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 실용적인 제너레이터 예제

```python
def read_large_file(file_path):
    """대용량 파일을 한 줄씩 읽기"""
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            yield line.strip()

def process_batches(items, batch_size):
    """아이템을 배치 단위로 처리"""
    batch = []
    for item in items:
        batch.append(item)
        if len(batch) == batch_size:
            yield batch
            batch = []
    if batch:  # 남은 아이템 처리
        yield batch

# 사용 예
for batch in process_batches(range(100), batch_size=10):
    print(f"Processing batch: {batch}")
```

---

## 컨텍스트 매니저

### with 문 활용

```python
# 파일 처리 (자동으로 close 호출)
with open("data.txt", "r", encoding="utf-8") as f:
    content = f.read()
    # 파일이 자동으로 닫힘

# 여러 컨텍스트 매니저
with open("input.txt", "r") as infile, \
     open("output.txt", "w") as outfile:
    outfile.write(infile.read())
```

### 커스텀 컨텍스트 매니저

```python
from contextlib import contextmanager
import time

@contextmanager
def timer(name):
    """실행 시간 측정 컨텍스트 매니저"""
    start = time.time()
    print(f"[{name}] 시작...")
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"[{name}] 완료: {elapsed:.2f}초")

# 사용
with timer("데이터 처리"):
    # 시간이 오래 걸리는 작업
    time.sleep(2)

# 클래스 기반 컨텍스트 매니저
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connection = None

    def __enter__(self):
        print(f"{self.db_name}에 연결 중...")
        self.connection = f"Connected to {self.db_name}"
        return self.connection

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"{self.db_name} 연결 종료")
        self.connection = None
        return False

# 사용
with DatabaseConnection("mydb") as conn:
    print(conn)
```

---

## 데코레이터

### 기본 데코레이터

```python
def log_function_call(func):
    """함수 호출을 로깅하는 데코레이터"""
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}...")
        result = func(*args, **kwargs)
        print(f"{func.__name__} completed")
        return result
    return wrapper

@log_function_call
def greet(name):
    return f"Hello, {name}!"

# 사용
greet("Alice")
# 출력:
# Calling greet...
# greet completed
```

### 인자를 받는 데코레이터

```python
def repeat(times):
    """함수를 여러 번 실행하는 데코레이터"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(times=3)
def get_random_number():
    import random
    return random.randint(1, 100)

# 사용
numbers = get_random_number()
print(numbers)  # [42, 87, 15] (예시)
```

### 실무에서 유용한 데코레이터

```python
from functools import wraps
import time

def retry(max_attempts=3, delay=1):
    """실패 시 재시도하는 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"Attempt {attempt + 1} failed: {e}")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def fetch_data_from_api():
    # API 호출 코드
    pass

# 캐싱 데코레이터
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_computation(n):
    """비용이 큰 계산 (결과 캐싱)"""
    print(f"Computing for {n}...")
    return n ** 2

# 첫 호출만 실제 계산, 이후는 캐시된 값 반환
print(expensive_computation(10))  # Computing for 10...
print(expensive_computation(10))  # 캐시에서 반환
```

---

## 타입 힌트

### 기본 타입 힌트

```python
from typing import List, Dict, Tuple, Optional, Union

def greet(name: str) -> str:
    return f"Hello, {name}!"

def process_numbers(numbers: List[int]) -> int:
    return sum(numbers)

def get_user_info(user_id: int) -> Dict[str, Union[str, int]]:
    return {
        "id": user_id,
        "name": "홍길동",
        "age": 30
    }

def find_user(user_id: int) -> Optional[Dict[str, str]]:
    # 사용자를 찾지 못하면 None 반환
    return None
```

### 고급 타입 힌트

```python
from typing import Callable, TypeVar, Generic

# TypeVar를 사용한 제네릭
T = TypeVar('T')

def first_element(items: List[T]) -> Optional[T]:
    return items[0] if items else None

# Callable 타입 (함수를 인자로 받을 때)
def apply_operation(
    value: int,
    operation: Callable[[int], int]
) -> int:
    return operation(value)

# 사용
result = apply_operation(5, lambda x: x ** 2)  # 25

# TypedDict (Python 3.8+)
from typing import TypedDict

class UserDict(TypedDict):
    name: str
    age: int
    email: str

def create_user(user_data: UserDict) -> None:
    print(f"Creating user: {user_data['name']}")

# Protocol을 사용한 구조적 서브타이핑 (Python 3.8+)
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None:
        ...

def render(obj: Drawable) -> None:
    obj.draw()
```

---

## 실무 베스트 프랙티스

### 1. 기본값 인자 처리

```python
# 나쁜 예: 가변 객체를 기본값으로 사용
def add_item(item, items=[]):  # 위험!
    items.append(item)
    return items

# 좋은 예
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

### 2. 예외 처리

```python
# 나쁜 예: 너무 광범위한 예외 처리
try:
    result = risky_operation()
except:
    pass

# 좋은 예: 구체적인 예외 처리
try:
    result = risky_operation()
except ValueError as e:
    logger.error(f"Invalid value: {e}")
    raise
except ConnectionError as e:
    logger.error(f"Connection failed: {e}")
    return default_value
```

### 3. 문자열 연결

```python
# 비효율적: 반복문에서 문자열 연결
result = ""
for item in items:
    result += str(item) + ", "

# 효율적: join 사용
result = ", ".join(str(item) for item in items)

# 또는 f-string 사용
items = ["apple", "banana", "cherry"]
message = f"Fruits: {', '.join(items)}"
```

### 4. 딕셔너리 다루기

```python
# get 메서드 활용
config = {"debug": True}
log_level = config.get("log_level", "INFO")  # 기본값 제공

# setdefault로 값 초기화
word_count = {}
for word in words:
    word_count.setdefault(word, 0)
    word_count[word] += 1

# defaultdict 사용 (더 Pythonic)
from collections import defaultdict
word_count = defaultdict(int)
for word in words:
    word_count[word] += 1
```

### 5. 리스트 다루기

```python
# any와 all 활용
numbers = [1, 2, 3, 4, 5]
has_even = any(n % 2 == 0 for n in numbers)
all_positive = all(n > 0 for n in numbers)

# filter와 map
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
squared = list(map(lambda x: x ** 2, numbers))

# 하지만 리스트 컴프리헨션이 더 Pythonic
even_numbers = [x for x in numbers if x % 2 == 0]
squared = [x ** 2 for x in numbers]
```

### 6. 경로 처리

```python
# os.path 대신 pathlib 사용 (Python 3.4+)
from pathlib import Path

# 경로 조작
base_dir = Path("/Users/buzz/projects")
config_file = base_dir / "config" / "settings.json"

# 파일 존재 확인
if config_file.exists():
    content = config_file.read_text()

# 디렉토리 생성
logs_dir = base_dir / "logs"
logs_dir.mkdir(parents=True, exist_ok=True)

# 파일 검색
py_files = list(base_dir.glob("**/*.py"))
```

### 7. 환경 변수와 설정

```python
import os
from dataclasses import dataclass

@dataclass
class Config:
    """애플리케이션 설정"""
    debug: bool = False
    database_url: str = "sqlite:///db.sqlite3"
    secret_key: str = "default-secret-key"

    @classmethod
    def from_env(cls):
        """환경 변수에서 설정 로드"""
        return cls(
            debug=os.getenv("DEBUG", "false").lower() == "true",
            database_url=os.getenv("DATABASE_URL", cls.database_url),
            secret_key=os.getenv("SECRET_KEY", cls.secret_key)
        )

# 사용
config = Config.from_env()
```

### 8. 로깅

```python
import logging

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

# 사용
logger.debug("디버그 메시지")
logger.info("정보 메시지")
logger.warning("경고 메시지")
logger.error("에러 메시지", exc_info=True)
```

---

## 참고 자료

- [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008/)
- [PEP 20 - The Zen of Python](https://peps.python.org/pep-0020/)
- [Python Documentation](https://docs.python.org/3/)
- [Effective Python (책)](https://effectivepython.com/)
- [Fluent Python (책)](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/)

*마지막 업데이트: 2025년 12월*
